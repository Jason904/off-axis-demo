<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Off-Axis 3D Display</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: white;
            text-align: center;
        }

        #start-btn {
            padding: 15px 40px;
            font-size: 24px;
            background: #ffffff;
            color: #000;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            margin-top: 20px;
            font-weight: bold;
        }

        #start-btn:hover {
            background: #ccc;
        }

        #debug-video,
        #debug-canvas {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 160px;
            height: 120px;
            z-index: 100;
            opacity: 0.8;
            transform: scaleX(-1);
            border: 1px solid #333;
            background: #000;
            pointer-events: none;
        }

        #status {
            margin-bottom: 20px;
            font-size: 18px;
            color: #aaa;
        }

        #fullscreen-btn {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1001;
            padding: 10px 15px;
            font-size: 14px;
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
            border: 1px solid #00ffff;
            cursor: pointer;
            border-radius: 4px;
            font-family: monospace;
            transition: all 0.2s ease;
        }

        #fullscreen-btn:hover {
            background: rgba(0, 255, 255, 0.4);
        }

        /* Iron Man Cursor */
        #hand-cursor {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid #00ffff;
            border-radius: 50%;
            box-shadow: 0 0 10px #00ffff, inset 0 0 5px #00ffff;
            pointer-events: none;
            z-index: 2000;
            transform: translate(-50%, -50%);
            display: none;
            /* Hidden by default until hand detected */
            transition: opacity 0.2s;
        }

        #hand-cursor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        /* --- New UI: Mission Briefing & Help --- */
        .monitor-frame {
            border: 1px solid #00ffff;
            padding: 40px;
            background: rgba(0, 10, 20, 0.95);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.15), inset 0 0 50px rgba(0, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            max-width: 650px;
            width: 90%;
            font-family: 'Courier New', 'PingFang SC', 'Microsoft YaHei', sans-serif;
            position: relative;
            overflow: hidden;
        }

        /* Scanline effect */
        .monitor-frame::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        .monitor-frame h1 {
            border-bottom: 2px solid #00ffff;
            padding-bottom: 15px;
            margin-bottom: 25px;
            font-size: 28px;
            letter-spacing: 4px;
            text-shadow: 0 0 10px #00ffff;
            text-transform: uppercase;
        }

        .monitor-frame h1 small {
            font-size: 14px;
            opacity: 0.7;
            display: block;
            margin-top: 5px;
            letter-spacing: 1px;
        }

        .cap-item {
            display: flex;
            align-items: center;
            margin: 18px 0;
            text-align: left;
            padding: 12px 20px;
            background: linear-gradient(90deg, rgba(0, 255, 255, 0.1), transparent);
            border-left: 4px solid #00ffff;
            transition: all 0.3s;
        }

        .cap-item:hover {
            background: linear-gradient(90deg, rgba(0, 255, 255, 0.2), transparent);
            transform: translateX(10px);
        }

        .cap-item .icon {
            font-size: 24px;
            margin-right: 20px;
            min-width: 30px;
            text-shadow: 0 0 5px currentColor;
        }

        .cap-item .label {
            color: #00ffff;
            font-weight: bold;
            margin-right: 15px;
            font-size: 16px;
            letter-spacing: 1px;
        }

        .cap-item .desc {
            color: #ccc;
            font-size: 14px;
            opacity: 0.9;
        }

        #start-btn {
            background: transparent;
            color: #00ffff;
            border: 2px solid #00ffff;
            padding: 15px 60px;
            font-size: 20px;
            font-family: 'Courier New', 'PingFang SC', sans-serif;
            font-weight: bold;
            letter-spacing: 4px;
            margin-top: 40px;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
            transition: all 0.3s;
            position: relative;
            z-index: 10;
            text-transform: uppercase;
        }

        #start-btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.6);
            transform: scale(1.02);
        }



        /* --- Cyberpunk dat.GUI Theme --- */
        .dg.ac {
            z-index: 9999 !important;
        }

        /* Main Container */
        .dg.main {
            border: 1px solid #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }

        /* Folder Titles */
        .dg ul .title {
            background-color: rgba(0, 20, 30, 0.95) !important;
            border-bottom: 1px solid #00ffff !important;
            color: #fff !important;
            text-shadow: none !important;
            font-family: 'Courier New', sans-serif !important;
            font-weight: bold;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        /* Rows */
        .dg .cr.function,
        .dg .cr.boolean,
        .dg .cr.string,
        .dg .cr.number {
            background-color: rgba(0, 10, 20, 0.9) !important;
            border-left: 4px solid #00ffff;
            /* The left accent bar */
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
        }

        /* Alternating rows slightly lighter? No, keep uniform dark for tech look */

        /* Labels */
        .dg .c .label {
            color: #ccc !important;
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif !important;
            font-size: 12px;
            text-shadow: none !important;
        }

        /* Input Fields (Text/Number) */
        .dg .c input[type=text] {
            background-color: rgba(0, 0, 0, 0.5) !important;
            color: #00ffff !important;
            border: 1px solid rgba(0, 255, 255, 0.3) !important;
            border-radius: 2px;
        }

        .dg .c input[type=text]:focus {
            outline: none;
            border-color: #00ffff !important;
            box-shadow: 0 0 5px #00ffff;
        }

        /* Sliders Background */
        .dg .c .slider {
            background-color: #111 !important;
            border: 1px solid #333;
            border-radius: 2px;
        }

        /* Slider Handle (Foreground) */
        .dg .c .slider-fg {
            background-color: #00ffff !important;
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
            border-radius: 1px;
        }

        .dg .c .slider:hover .slider-fg {
            background-color: #fff !important;
        }

        /* Close Button */
        .dg .close-button {
            background-color: #000 !important;
            color: #00ffff !important;
            border: 1px solid #00ffff;
            text-align: center;
        }

        .dg .close-button:hover {
            background-color: #00ffff !important;
            color: #000 !important;
        }

        /* Persistent Help Button - Moved to Bottom Right */
        #help-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(0, 10, 20, 0.8);
            border: 2px solid #00ffff;
            color: #00ffff;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            z-index: 2000;
            display: flex;
            /* Flex center */
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        #help-btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.8);
            transform: rotate(90deg);
        }

        /* Help Modal */
        #help-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2001;
            /* Above everything */
            align-items: center;
            justify-content: center;
        }

        /* Close btn for modal */
        .close-help {
            margin-top: 20px;
            background: transparent;
            border: 1px solid #aaa;
            color: #aaa;
            padding: 5px 20px;
            cursor: pointer;
            font-family: inherit;
        }

        .close-help:hover {
            border-color: #fff;
            color: #fff;
        }
    </style>
</head>

<body>

    <div id="canvas-container"></div>

    <div id="overlay">
        <div class="monitor-frame">
            <h1>Á≥ªÁªüÂ∞±Áª™</h1>

            <div class="capabilities-list">
                <div class="cap-item">
                    <span class="icon">üß†</span>
                    <div><span class="label">ËßÜÂ∑ÆÊ†°ÂáÜÁ≥ªÁªü:</span> <span class="desc">ÂÖ®ÊÅØÂ§¥ÈÉ®ËøΩË∏™Â∑≤ÊøÄÊ¥ª</span></div>
                </div>
                <div class="cap-item">
                    <span class="icon">‚úã</span>
                    <div><span class="label">ÂÖâÂ≠ê‰∫§‰∫íÈòµÂàó:</span> <span class="desc">ÊâãÈÉ®Âä®ÊÄÅÂÖâÊ∫êÊéßÂà∂</span></div>
                </div>
                <div class="cap-item">
                    <span class="icon">‚úä</span>
                    <div><span class="label">‰ø°‰ª§ËØÜÂà´Ê®°Âùó:</span> <span class="desc">Êè°Êã≥ÂæÖÊú∫ / Âº†ÊâãÂÖÖËÉΩ</span></div>
                </div>
            </div>

            <div id="status" style="margin-top:20px; color:#aaa; font-size:12px;">Á≠âÂæÖÁîüÁâ©‰ΩìÊé•ÂÖ•...</div>
            <button id="start-btn">>> ÂêØÂä®ÂÖ®ÊÅØÊäïÂΩ± <<</button>
        </div>
    </div>

    <!-- Buttons -->
    <button id="help-btn" title="Êü•ÁúãÊìç‰ΩúÊâãÂÜå">?</button>

    <!-- Help Modal -->
    <div id="help-modal">
        <div class="monitor-frame">
            <h1>Êìç‰ΩúÊâãÂÜå</h1>

            <div class="capabilities-list">
                <div class="cap-item">
                    <span class="icon">üëÅÔ∏è</span>
                    <div><span class="label">ÂÖ®ÊÅØËßÜËßí:</span> <span class="desc">ÁßªÂä®Â§¥ÈÉ®‰ª•ÊîπÂèòËßÇÂØüËßíÂ∫¶„ÄÇ</span></div>
                </div>
                <div class="cap-item">
                    <span class="icon">‚úã</span>
                    <div><span class="label">ÂÖâÊ∫êÁâµÂºï:</span> <span class="desc">‰∏æËµ∑Âè≥ÊâãÁßªÂä®‰ª•ÊéßÂà∂ÂÖâÁÖßÁÇπ„ÄÇ</span></div>
                </div>
                <div class="cap-item">
                    <span class="icon">ü§è</span>
                    <div><span class="label">Á∫µÊ∑±ÊéßÂà∂:</span> <span class="desc">ÂâçÂêéÁßªÂä®ÊâãÊéåÊéßÂà∂ÂÖâÊ∫êË∑ùÁ¶ª„ÄÇ</span></div>
                </div>
            </div>

            <button class="close-help" onclick="document.getElementById('help-modal').style.display='none'">[ ÂÖ≥Èó≠
                ]</button>
        </div>
    </div>

    <!-- Hidden video for processing -->
    <video id="debug-video" playsinline style="display:none"></video>
    <!-- Visual feedback of tracking -->
    <canvas id="debug-canvas"></canvas>



    <!-- Fullscreen Button -->
    <button id="fullscreen-btn">‚õ∂ ÂÖ®Â±èÊ®°Âºè</button>

    <!-- Iron Man Cursor -->
    <div id="hand-cursor"></div>

    <!-- Hidden Input for Model Upload -->
    <input type="file" id="model-upload" accept=".glb,.gltf" style="display: none;">

    <!-- MediaPipe via traditional scripts (not ES modules) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <!-- dat.gui for controls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

        // Global variables for controls
        let mainLight, ambientLight;
        let mixer; // Animation Mixer

        // --- GUI Controls ---
        const params = {
            currentModel: 'Harbinger Cruiser',
            scale: 1.3,
            rotationY: 1.0,
            positionZ: 5.0,
            positionY: 9.0, // Added Y control
            lightIntensity: 5000,
            ambientIntensity: 5.0,
            gridSpeed: 5.0
        };

        // --- Configuration ---
        const SCREEN_WIDTH_CM = 30.0;
        const SCREEN_HEIGHT_CM = 20.0;
        const BOX_DEPTH_CM = 80.0; // Deep virtual chamber

        // Tracking constants
        const DEFAULT_HEAD_Z = 60.0;
        const NEAR = 0.5;
        const FAR = 1000.0;

        // --- State ---
        const state = {
            head: new THREE.Vector3(0, 0, DEFAULT_HEAD_Z),
            targetHead: new THREE.Vector3(0, 0, DEFAULT_HEAD_Z),
            trackingActive: false,
            // Iron Man Light State
            lightPos: new THREE.Vector3(0, 20, 10), // Current smoothed pos
            targetLightPos: new THREE.Vector3(0, 20, 10), // Target from hand
            lightIntensity: 5000,
            targetLightIntensity: 5000,
            handDetected: false
        };

        // --- Setup Three.js ---
        const container = document.getElementById('canvas-container');
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); // Pure black for deep void

        const camera = new THREE.Camera();
        scene.add(camera);

        // Global variables for controls
        let gridUniforms; // For shader animation

        // --- Environment: Deep Virtual Chamber ---
        function createEnvironment() {
            const group = new THREE.Group();
            scene.add(group);

            const w = SCREEN_WIDTH_CM;
            const h = SCREEN_HEIGHT_CM;
            const d = BOX_DEPTH_CM;

            // 1. Custom Grid Geometry with VARIABLE DENSITY
            // Denser near front (z=0), sparser toward back (z=-d)
            const vertices = [];

            // --- Floor & Ceiling (X-axis lines running into depth) ---
            const stepX = 2.0; // X spacing
            for (let x = -w / 2; x <= w / 2; x += stepX) {
                vertices.push(x, -h / 2, 0); vertices.push(x, -h / 2, -d);
                vertices.push(x, h / 2, 0); vertices.push(x, h / 2, -d);
            }

            // --- Floor/Ceiling Horizontals with VARIABLE Z spacing ---
            // Use exponential spacing: denser near front
            const numZLines = 20;
            for (let i = 0; i <= numZLines; i++) {
                // Exponential distribution: more lines near z=0
                const t = i / numZLines;
                const z = -d * Math.pow(t, 1.5); // Power curve for density falloff
                vertices.push(-w / 2, -h / 2, z); vertices.push(w / 2, -h / 2, z);
                vertices.push(-w / 2, h / 2, z); vertices.push(w / 2, h / 2, z);
            }

            // --- Walls (Verticals) with variable Z spacing ---
            for (let i = 0; i <= numZLines; i++) {
                const t = i / numZLines;
                const z = -d * Math.pow(t, 1.5);
                vertices.push(-w / 2, -h / 2, z); vertices.push(-w / 2, h / 2, z); // Left
                vertices.push(w / 2, -h / 2, z); vertices.push(w / 2, h / 2, z);   // Right
            }

            // --- Back Wall ---
            for (let x = -w / 2; x <= w / 2; x += stepX) {
                vertices.push(x, -h / 2, -d); vertices.push(x, h / 2, -d);
            }
            for (let y = -h / 2; y <= h / 2; y += stepX) {
                vertices.push(-w / 2, y, -d); vertices.push(w / 2, y, -d);
            }

            // --- Wall Horizontals (Left/Right) with variable Z spacing ---
            for (let y = -h / 2; y <= h / 2; y += stepX) {
                vertices.push(-w / 2, y, 0); vertices.push(-w / 2, y, -d); // Left
                vertices.push(w / 2, y, 0); vertices.push(w / 2, y, -d);   // Right
            }

            const gridGeo = new THREE.BufferGeometry();
            gridGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

            gridUniforms = {
                time: { value: 0 },
                color: { value: new THREE.Color(0x00ffff) }
            };

            const shaderMat = new THREE.ShaderMaterial({
                uniforms: gridUniforms,
                vertexShader: `
                    uniform float time;
                    varying vec3 vPos;
                    void main() {
                        vPos = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color;
                    varying vec3 vPos;
                    
                    void main() {
                        // Electric Pulse
                        float pulseSpd = time * 2.0; 
                        
                        // Smooth sine wave for organic glow
                        float sWave = sin(vPos.z * 0.1 + pulseSpd) * 0.5 + 0.5;
                        
                        // Base glow (brighter in foreground)
                        float baseGlow = 0.3 + sWave * 0.7;
                        
                        // Strong distance fade for deep chamber effect
                        // Objects far away (z << 0) fade to black
                        float distFade = smoothstep(-80.0, 0.0, vPos.z);
                        distFade = pow(distFade, 1.5); // Enhance contrast
                        
                        // Foreground boost
                        float foregroundBoost = smoothstep(-20.0, 5.0, vPos.z) * 0.5;
                        
                        float finalAlpha = distFade * (baseGlow + foregroundBoost);
                        
                        gl_FragColor = vec4(color * (baseGlow + foregroundBoost), finalAlpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            const gridLines = new THREE.LineSegments(gridGeo, shaderMat);
            group.add(gridLines);

            // 2. Solid dark walls
            const boxGeo = new THREE.BoxGeometry(w, h, d);
            boxGeo.translate(0, 0, -d / 2);
            const wallMat = new THREE.MeshBasicMaterial({ color: 0x000205, side: THREE.BackSide });
            const walls = new THREE.Mesh(boxGeo, wallMat);
            group.add(walls);

            // 3. Lighting
            ambientLight = new THREE.AmbientLight(0xffffff, params.ambientIntensity);
            scene.add(ambientLight);

            mainLight = new THREE.SpotLight(0xffffff, params.lightIntensity);
            mainLight.position.set(0, 20, 10);
            mainLight.angle = Math.PI / 4;
            mainLight.penumbra = 0.5;
            mainLight.castShadow = true;
            mainLight.shadow.bias = -0.0001;
            scene.add(mainLight);

            const rimLight = new THREE.PointLight(0x00ffff, 1, 50);
            rimLight.position.set(0, -10, -10);
            scene.add(rimLight);

            return { pedestalTopY: -h / 2, pedestalZ: -d / 2 };
        }

        const envInfo = createEnvironment();

        // --- Model Selection ---
        const models = {
            'Default': './models/default/scene.gltf',
            'Electric Horse': './models/allan_pinkerton_electric_horse/scene.gltf',
            'Harbinger Cruiser': './models/d.s.s._harbinger_battle_cruiser/scene.gltf'
        };
        params.currentModel = 'Harbinger Cruiser';

        let modelController;        // Initialize Controls (Hidden by Default, in Modal)
        function setupControls() {
            // Restore Floating GUI
            const gui = new dat.GUI();
            // Hide initially (will show on start)
            gui.domElement.parentElement.style.display = 'none';

            const folderModel = gui.addFolder('Ê®°ÂûãÈÖçÁΩÆ');
            folderModel.open();

            // Save reference to update later
            modelController = folderModel.add(params, 'currentModel', Object.keys(models)).name('ÈÄâÊã©Ê®°Âûã').onChange(loadModel);

            // Add Upload Button
            const uploadObj = {
                upload: function () {
                    document.getElementById('model-upload').click();
                }
            };
            folderModel.add(uploadObj, 'upload').name('üìÇ ËΩΩÂÖ•Êú¨Âú∞Êñá‰ª∂');

            // Model Transform
            folderModel.add(params, 'scale', 0.1, 3).name('Áº©ÊîæÊØî‰æã').onChange(updateModelTransform);
            folderModel.add(params, 'rotationY', -3.14, 3.14).name('YËΩ¥ÊóãËΩ¨').onChange(updateModelTransform);
            folderModel.add(params, 'positionZ', -10, 10).name('ZËΩ¥‰ΩçÁßª').onChange(updateModelTransform);
            folderModel.add(params, 'positionY', -10, 20).name('YËΩ¥‰ΩçÁßª').onChange(updateModelTransform);

            const folderLight = gui.addFolder('ÂÖâÁÖßÁ≥ªÁªü');
            folderLight.open();
            // params.lightIntensity is used as the "Max" intensity in Iron Man mode
            folderLight.add(params, 'lightIntensity', 0, 10000).name('Ê†∏ÂøÉ‰∫ÆÂ∫¶').onChange(val => {
                if (mainLight && !state.handDetected) {
                    mainLight.intensity = val;
                }
            });
            folderLight.add(params, 'ambientIntensity', 0, 10).name('ÁéØÂ¢ÉÂÖâ').onChange(val => {
                if (ambientLight) ambientLight.intensity = val;
            });

            const folderEnv = gui.addFolder('ÁéØÂ¢ÉÂèÇÊï∞');
            folderEnv.open();
            folderEnv.add(params, 'gridSpeed', 0, 20).name('ÁΩëÊ†ºÊµÅÈÄü');
        }

        // --- File Upload Logic ---
        document.getElementById('model-upload').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const url = URL.createObjectURL(file);

            // Add special entry for custom model
            const customName = 'Custom: ' + file.name;
            models[customName] = url;

            // Update params to match
            params.currentModel = customName;

            // Vital: Update the GUI dropdown options
            // dat.GUI doesn't support dynamic options natively easily, 
            // but we can cheat by removing and re-adding, or updating the inner property.
            // The cleanest way in basic dat.GUI is to update the backing array if possible, 
            // or just recreate the controller. Let's try the recreate approach for stability
            // OR simpler: Just update the controller's internal list if we can.

            // Standard dat.GUI hack to update options:
            if (modelController) {
                modelController = modelController.options(Object.keys(models));
                modelController.name('ÈÄâÊã©Ê®°Âûã'); // Reset name
                modelController.onChange(loadModel); // Re-bind listener
                modelController.setValue(customName); // Update UI display
            }

            loadModelFromURL(url);

            // Optional: Alert user
            console.log("Loaded custom model:", file.name);
        });

        function loadModelFromURL(url) {
            // Clear existing
            while (modelGroup.children.length > 0) {
                modelGroup.remove(modelGroup.children[0]);
            }

            loader.load(url, (gltf) => {
                const m = gltf.scene;

                // Normalize size
                const box = new THREE.Box3().setFromObject(m);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                const maxDim = Math.max(size.x, size.y, size.z);
                const fitScale = 22.0 / maxDim; // Fit to 22cm

                m.scale.set(fitScale, fitScale, fitScale);
                m.position.sub(center.multiplyScalar(fitScale));

                modelGroup.add(m);

                m.traverse(c => {
                    if (c.isMesh) {
                        c.castShadow = true;
                        c.receiveShadow = true;
                    }
                });

                if (gltf.animations && gltf.animations.length > 0) {
                    mixer = new THREE.AnimationMixer(m);
                    gltf.animations.forEach((clip) => {
                        mixer.clipAction(clip).play();
                    });
                } else {
                    mixer = null;
                }

                updateModelTransform();

            }, undefined, (err) => {
                console.warn("Model load failed", err);
                alert("Errod loading model: " + err.message);
            });
        }

        // Helper to apply params
        function updateModelTransform() {
            if (!modelGroup || modelGroup.children.length === 0) return;

            // We apply scale to the group, which contains the gltf model
            modelGroup.scale.set(params.scale, params.scale, params.scale);

            modelGroup.rotation.y = params.rotationY;
            modelGroup.position.z = params.positionZ;
            modelGroup.position.y = params.positionY + envInfo.pedestalTopY;
        }

        const loader = new GLTFLoader();

        // Setup Draco Loader
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
        loader.setDRACOLoader(dracoLoader);

        let modelGroup = new THREE.Group();
        scene.add(modelGroup);

        // Position the group on top of the pedestal
        modelGroup.position.y = envInfo.pedestalTopY;
        // Z is controlled by params

        function loadModel(modelName) {
            const url = models[modelName];
            if (!url) return;

            // Clear existing
            while (modelGroup.children.length > 0) {
                modelGroup.remove(modelGroup.children[0]);
            }

            loader.load(url, (gltf) => {
                const m = gltf.scene;

                // Normalize size
                const box = new THREE.Box3().setFromObject(m);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                // Make it HUGE to feel like it's overflowing
                // Fit to approx 22cm (Screen height is 20cm)
                const maxDim = Math.max(size.x, size.y, size.z);
                const fitScale = 22.0 / maxDim;

                // Apply initial fit scale to the loaded model itself
                m.scale.set(fitScale, fitScale, fitScale);

                // Re-center locally
                m.position.sub(center.multiplyScalar(fitScale));

                modelGroup.add(m);

                // Reset params if needed, or keep previous adjustment
                // Let's reset rotation but keep z/scale if user tuned it? 
                // Actually better to keep user params active.

                m.traverse(c => {
                    if (c.isMesh) {
                        c.castShadow = true;
                        c.receiveShadow = true;
                    }
                });

                // Handle Animations
                if (gltf.animations && gltf.animations.length > 0) {
                    mixer = new THREE.AnimationMixer(m);
                    gltf.animations.forEach((clip) => {
                        mixer.clipAction(clip).play();
                    });
                } else {
                    mixer = null;
                }

                updateModelTransform();

            }, undefined, (err) => {
                console.warn("Model load failed", err);
            });
        }

        // Initial Load
        loadModel(params.currentModel);
        setupControls();


        // --- Off-Axis Logic ---
        function updateCamera(head) {
            camera.position.copy(head);
            const dist = head.z;
            if (dist < 0.1) return;

            const halfW = SCREEN_WIDTH_CM / 2;
            const halfH = SCREEN_HEIGHT_CM / 2;
            const scale = NEAR / dist;

            const left = (-halfW - head.x) * scale;
            const right = (halfW - head.x) * scale;
            const bottom = (-halfH - head.y) * scale;
            const top = (halfH - head.y) * scale;

            camera.projectionMatrix.makePerspective(left, right, top, bottom, NEAR, FAR);
        }

        // --- Tracking ---
        async function startTracking() {
            try {
                // FaceMesh and Camera are loaded globally via script tags
                const video = document.getElementById('debug-video');
                const canvas = document.getElementById('debug-canvas');
                const ctx = canvas.getContext('2d');

                const faceMesh = new FaceMesh({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });

                faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                faceMesh.onResults(results => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

                    if (results.multiFaceLandmarks.length > 0) {
                        state.trackingActive = true;
                        const lm = results.multiFaceLandmarks[0];
                        const lIris = lm[468], rIris = lm[473]; // Iris centers

                        if (lIris && rIris) {
                            const cx = (lIris.x + rIris.x) / 2;
                            const cy = (lIris.y + rIris.y) / 2;

                            // Distance calc
                            const dx = lIris.x - rIris.x;
                            const dy = lIris.y - rIris.y;
                            const dPx = Math.sqrt(dx * dx + dy * dy);

                            // Tuned Calibration
                            // If user is 60cm away, eyes ~0.1 normalized distance?
                            // Let's approximate: z (cm) ~= CALIBRATION / dPx
                            // CALIBRATION needs tuning.
                            let z = 4.5 / dPx;
                            z = THREE.MathUtils.clamp(z, 15, 120);

                            // XY Mapping
                            // 0.5 is center.
                            // Sensitivity: How much head movement scales to world movement.
                            const SENSITIVITY = 2.5;
                            const wx = (0.5 - cx) * SCREEN_WIDTH_CM * SENSITIVITY;
                            const wy = (0.5 - cy) * SCREEN_HEIGHT_CM * SENSITIVITY * 0.8; // Lower Y sensitivity

                            // Constrain head to reasonable viewing box
                            const LIMIT_X = 50;
                            const LIMIT_Y = 50;

                            state.targetHead.set(
                                THREE.MathUtils.clamp(wx, -LIMIT_X, LIMIT_X),
                                THREE.MathUtils.clamp(wy, -LIMIT_Y, LIMIT_Y),
                                z
                            );

                            // Debug
                            ctx.fillStyle = '#00ff00';
                            ctx.beginPath();
                            ctx.arc(cx * canvas.width, cy * canvas.height, 5, 0, 6.28);
                            ctx.fill();
                        }
                    }
                });

                // --- HAND TRACKING SETUP ---
                const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                const handCursor = document.getElementById('hand-cursor');

                hands.onResults(results => {
                    // Logic to update Light State
                    if (results.multiHandLandmarks.length > 0) {
                        state.handDetected = true;
                        handCursor.style.display = 'block';

                        const lm = results.multiHandLandmarks[0];

                        // 1. Palm Center (Approximate with wrist + middle finger base)
                        // Landmark 0: Wrist, 9: Middle Finger MCP
                        const wrist = lm[0];
                        const middleMCP = lm[9];
                        const cx = (wrist.x + middleMCP.x) / 2;
                        const cy = (wrist.y + middleMCP.y) / 2;

                        // 2. Cursor Update (Invert X for mirror effect)
                        // Canvas is scaleX(-1) so visual feedback needs careful handling.
                        // Actually, if we use CSS left/top on screen coordinates:
                        // MediaPipe x is 0-1 (normalized). 
                        // If video is mirrored: x=0 is right, x=1 is left.
                        // Let's just map directly to screen pixels.

                        // NOTE: If we want "Mirror" feel: Moving hand RIGHT (your right) should go to screen RIGHT.
                        // In video stream, right hand moving right appears on LEFT side of image?
                        // Let's assume standard mirror behavior.

                        const screenX = (1.0 - cx) * window.innerWidth;
                        const screenY = cy * window.innerHeight;

                        handCursor.style.transform = `translate(${screenX}px, ${screenY}px)`;


                        // 3. Map to 3D Light Position
                        // Scene width ~30cm. 
                        // Map 0..1 to -20..20 approx?
                        const mapRange = (val, inMin, inMax, outMin, outMax) => {
                            return (val - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
                        };

                        const targetX = mapRange(1.0 - cx, 0, 1, -25, 25);
                        const targetY = mapRange(cy, 0, 1, 15, -15); // Top (0) is high Y (+15)

                        // 4. Depth (Z) from Hand Size
                        // Distance between Wrist(0) and Middle Finger TIP(12) or MCP(9)
                        // Larger distance = Closer hand
                        const dx = wrist.x - middleMCP.x;
                        const dy = wrist.y - middleMCP.y;
                        const handSize = Math.sqrt(dx * dx + dy * dy); // usually 0.1 to 0.3

                        // Size 0.2 -> Z = 10 (Close)
                        // Size 0.05 -> Z = -10 (Far)
                        // Let's tune:
                        let targetZ = mapRange(handSize, 0.05, 0.25, -20, 20);
                        targetZ = THREE.MathUtils.clamp(targetZ, -30, 30);

                        state.targetLightPos.set(targetX, targetY, targetZ);


                        // 5. Gesture (Fist vs Open) -> Switch
                        // Optimized Logic: Distance Ratio of Index Finger
                        // Ratio = Dist(Wrist, Tip8) / Dist(Wrist, MCP5)
                        // Open Hand: Ratio > 1.6 usually.
                        // Fist: Ratio < 1.3 usually.

                        const tip = lm[8];
                        const base = lm[5];
                        const dTip = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                        const dMCP = Math.sqrt(Math.pow(base.x - wrist.x, 2) + Math.pow(base.y - wrist.y, 2));

                        // Avoid divide by zero
                        const ratio = (dMCP > 0.001) ? (dTip / dMCP) : 0;

                        // Lower threshold to favor "Open" (Light ON)
                        // If it's ambiguous, we want Light ON.
                        if (ratio < 1.1) {
                            // FIST / CLOSED
                            state.targetLightIntensity = 100; // Dim
                            handCursor.style.borderColor = '#ff0000';
                            handCursor.style.boxShadow = '0 0 10px #ff0000, inset 0 0 5px #ff0000';
                        } else {
                            // OPEN -> Use GUI setting as Max Intensity
                            state.targetLightIntensity = params.lightIntensity;
                            handCursor.style.borderColor = '#00ffff';
                            handCursor.style.boxShadow = '0 0 10px #00ffff, inset 0 0 5px #00ffff';
                        }

                    } else {
                        state.handDetected = false;
                        handCursor.style.display = 'none';

                        // SAFETY FALLBACK:
                        // If tracking lost, FADE TO BLACK (as requested).
                        // Hand gone = Light gone.
                        state.targetLightIntensity = 0;
                    }
                });

                // Start Hands too!
                // NOTE: Camera utility only accepts ONE onFrame. We need to chain them.
                // Or: execute both send() in the single onFrame.

                const mediapipeCamera = new Camera(video, {
                    onFrame: async () => {
                        await faceMesh.send({ image: video });
                        await hands.send({ image: video });
                    },
                    width: 640,
                    height: 480
                });

                await mediapipeCamera.start();

                // Hide overlay on success
                document.getElementById('overlay').style.display = 'none';

                // Show Settings Panel (dat.GUI)
                const guiContainer = document.querySelector('.dg.ac');
                if (guiContainer) guiContainer.style.display = 'block';

            } catch (e) {
                console.error(e);
                document.getElementById('status').innerText = "Error starting camera: " + e.message;
            }
        }

        // --- Interaction ---
        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('status').innerText = "Initializing Camera & Models...";
            startTracking();
        });

        // --- Loop ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);

            // Time & Delta
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            if (gridUniforms) {
                gridUniforms.time.value = time * params.gridSpeed;
            }

            // Update Mixer
            if (mixer) mixer.update(delta);

            // Smoothing
            const alpha = 0.1; // Smooth factor
            state.head.lerp(state.targetHead, alpha);

            // Iron Man Light Smoothing
            // ALWAYS run intensity smoothing

            const lightAlpha = 0.15;
            if (state.handDetected) {
                // Tracking Hand
                state.lightPos.lerp(state.targetLightPos, lightAlpha);
            } else {
                // LOST TRACKING -> Auto-Return to Center (Drift back)
                // This fixes the "Loophole" where light gets stuck at edge if hand exits quickly.
                const defaultPos = new THREE.Vector3(0, 20, 10);
                state.lightPos.lerp(defaultPos, 0.02); // Very slow, graceful return
            }

            // Intensity LERP
            state.lightIntensity += (state.targetLightIntensity - state.lightIntensity) * 0.1;

            // Apply to scene
            if (mainLight) {
                mainLight.position.copy(state.lightPos);
                mainLight.intensity = state.lightIntensity;
            }

            updateCamera(state.head);
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Fullscreen Toggle ---
        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.warn('Fullscreen request failed:', err);
                });
            } else {
                document.exitFullscreen();
            }
        });

        document.addEventListener('fullscreenchange', () => {
            const btn = document.getElementById('fullscreen-btn');
            if (document.fullscreenElement) {
                btn.textContent = '‚õ∂ ÈÄÄÂá∫ÂÖ®Â±è';
            } else {
                btn.textContent = '‚õ∂ ÂÖ®Â±èÊ®°Âºè';
            }
        });

        // Toggle Help
        document.getElementById('help-btn').addEventListener('click', () => {
            const modal = document.getElementById('help-modal');
            modal.style.display = 'flex'; // Use flex to center
        });
    </script>
</body>

</html>